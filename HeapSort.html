<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap Sort - Interactive Workbench</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code:wght@400;500;600&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #3b82f6;
            --secondary: #64748b;
            --accent: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --bg-page: #f8fafc;
            --bg-panel: #ffffff;
            --border: #e2e8f0;
            --code-bg: #1e293b;
            
            /* Trace Log Colors */
            --trace-bg: #f3f4f6;
            --trace-hl-purple: #e9d5ff; /* Parent */
            --trace-hl-yellow: #fef08a; /* Child */
            --trace-hl-green: #86efac;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-page);
            color: #1e293b;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        /* --- HEADER --- */
        header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 15px 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 70px;
            flex-shrink: 0;
            z-index: 10;
            position: relative;
        }

        .brand { display: flex; align-items: center; gap: 15px; }
        .brand h1 { font-size: 1.5rem; font-weight: 800; color: #0f172a; }
        .brand .emoji { font-size: 1.8rem; }

        /* --- MAIN LAYOUT --- */
        .workbench {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            gap: 20px;
        }

        /* --- THEORY AREA --- */
        .theory-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: stretch;
        }
        @media (max-width: 600px) { .theory-area { grid-template-columns: 1fr; } }

        .details-panel {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
            min-height: 400px;
        }

        .panel-title {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            color: var(--secondary);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .scenario-content {
            background: #fffbeb;
            border: 1px solid #fcd34d;
            color: #92400e;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.95rem;
            line-height: 1.5;
            margin-bottom: 10px;
        }

        /* Code Block */
        .code-container {
            background: var(--code-bg);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .code-header-row {
            display: flex; justify-content: space-between; align-items: center;
            background: #0f172a; padding: 8px 10px; border-bottom: 1px solid #334155;
            flex-wrap: wrap; gap: 10px;
        }

        .code-tabs, .view-mode-tabs { display: flex; gap: 2px; }
        .tab, .view-btn {
            background: transparent; border: none; color: #94a3b8;
            padding: 6px 12px; font-size: 0.8rem; font-weight: 600;
            cursor: pointer; border-radius: 6px; transition: 0.2s;
        }
        .tab:hover, .view-btn:hover { background: rgba(255,255,255,0.1); }
        .tab.active { background: #334155; color: white; }
        .view-btn.active { background: #3b82f6; color: white; }

        .code-editor {
            padding: 15px; font-family: 'Fira Code', monospace;
            font-size: 0.85rem; line-height: 1.6; color: #e2e8f0;
            overflow-x: auto; flex: 1; 
        }

        .code-line { padding: 2px 10px; border-radius: 4px; white-space: pre; }
        .code-line.active-line {
            background: rgba(251, 191, 36, 0.2);
            border-left: 3px solid var(--warning); color: #fbbf24;
        }
        
        .comment-time { color: #f59e0b; font-style: italic; font-weight: bold; }
        .comment-space { color: #3b82f6; font-style: italic; font-weight: bold; }
        .comment-std { color: #94a3b8; font-style: italic; }

        /* --- LOGIC LIST STYLES --- */
        .logic-list ol { 
            list-style: none; counter-reset: logic-counter; padding: 0; margin: 0;
        }
        .logic-list li {
            display: flex; align-items: flex-start; padding: 10px 0; 
            border-bottom: 1px solid #f1f5f9; font-size: 0.95rem; color: #334155;
        }
        .logic-list li::before {
            counter-increment: logic-counter; content: counter(logic-counter) ".";
            color: var(--primary); font-weight: 700; min-width: 25px; margin-right: 5px;
        }

        /* --- VISUAL SECTION --- */
        .visual-area {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .stage-container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            height: 600px; min-height: 600px;
            display: flex; flex-direction: column;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .stage-header {
            padding: 15px 20px; border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
            height: 60px; flex-shrink: 0;
        }
        
        .status-badge {
            background: #e0f2fe; color: #0369a1; padding: 5px 12px;
            border-radius: 20px; font-size: 0.85rem; font-weight: 600;
        }

        /* --- SPLIT LAYOUT (50/50) --- */
        .visual-body {
            display: flex; flex: 1; overflow: hidden;
        }

        /* LEFT: Graph (50%) - NOW A CANVAS */
        .canvas-wrapper {
            flex: 1; position: relative;
            display: flex; align-items: center; justify-content: center;
            background-color:  rgb(214, 172, 147); border-right: 1px solid var(--border);
        }
        
        #treeCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* RIGHT: Trace Log (50%) */
        .trace-wrapper {
            flex: 1; display: flex; flex-direction: column;
            background: #ffffff; height: 100%; overflow: hidden;
        }

        /* --- LOGS --- */
        .trace-header {
            padding: 10px 20px; border-bottom: 1px solid #f1f5f9; background: #f8fafc;
            font-size: 0.8rem; text-transform: uppercase; font-weight: 700; color: var(--secondary);
            display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;
        }

        .trace-log-container {
            flex: 1; overflow-y: auto; padding: 20px;
            display: flex; flex-direction: column; gap: 12px;
            font-family: 'Fira Code', monospace; scroll-behavior: smooth;
        }
        .trace-log-container::-webkit-scrollbar { width: 6px; }
        .trace-log-container::-webkit-scrollbar-track { background: transparent; }
        .trace-log-container::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 10px; border: 2px solid transparent; background-clip: content-box; }
        .trace-log-container::-webkit-scrollbar-thumb:hover { background-color: #94a3b8; }

        .trace-step {
            display: flex; flex-direction: column; gap: 6px; 
            padding-bottom: 12px; border-bottom: 1px solid #f1f5f9;
            animation: fadeIn 0.3s ease;
        }
        .step-info { color: #64748b; font-size: 0.75rem; font-weight: 700; text-transform: uppercase; }
        .step-msg { font-size: 0.85rem; color: #334155; line-height: 1.4; }
        
        .hl-parent { background: var(--trace-hl-purple); padding: 2px 4px; border-radius: 4px; font-weight: 700; }
        .hl-child { background: var(--trace-hl-yellow); padding: 2px 4px; border-radius: 4px; font-weight: 700; }

        .array-state { background: var(--trace-bg); padding: 6px 10px; border-radius: 6px; font-size: 0.8rem; color: #475569; overflow-x: auto; white-space: nowrap; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* --- CONTROLS --- */
        .controls-toolbar {
            background: white; padding: 15px 20px; border-top: 1px solid var(--border);
            display: flex; gap: 20px; align-items: center; flex-wrap: wrap;
            justify-content: center; flex-shrink: 0;
        }
        .control-group { display: flex; align-items: center; gap: 10px; padding-right: 20px; border-right: 1px solid var(--border); }
        .control-group:last-child { border: none; }

        button.btn {
            padding: 10px 18px; border-radius: 8px; border: 1px solid var(--border);
            background: white; font-weight: 600; cursor: pointer; transition: 0.2s;
            display: flex; align-items: center; gap: 6px; font-size: 0.95rem;
        }
        button.btn:hover { background: #f8fafc; border-color: #cbd5e1; }
        button.btn-primary { background: var(--primary); color: white; border: none; }
        button.btn-primary:hover { background: #2563eb; }
        button.btn-primary:disabled { background: #94a3b8; cursor: not-allowed; }
        button.btn#btnPause.active { background: #fef3c7; color: #92400e; border-color: #fcd34d; }
        button.btn-danger { color: var(--danger); border-color: #fca5a5; background: #fef2f2; }
        input[type="text"] { padding: 10px 12px; border: 1px solid var(--border); border-radius: 6px; width: 200px; font-family: 'Fira Code', monospace; }

        /* Dropdown */
        .dropdown { position: relative; display: inline-block; }
        .dropdown-content {
            display: none; position: absolute; bottom: 100%; left: 0;
            background-color: white; min-width: 160px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.15); border-radius: 8px;
            border: 1px solid var(--border); z-index: 50;
        }
        .dropdown:hover .dropdown-content { display: block; }
        .dropdown-item { padding: 10px 16px; cursor: pointer; font-size: 0.9rem; color: #334155; display: block; border-bottom: 1px solid #f1f5f9; transition: 0.2s; }
        .dropdown-item:last-child { border-bottom: none; }
        .dropdown-item:hover { background-color: #f8fafc; color: var(--primary); }

        /* --- COMPLEXITY SECTION --- */
        .complexity-section { background: white; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); padding: 20px; border: 1px solid var(--border); }
        .complexity-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
        .complexity-table th { text-align: left; padding: 12px 15px; background: #f8fafc; color: #64748b; font-weight: 600; border-bottom: 2px solid var(--border); }
        .complexity-table td { padding: 12px 15px; border-bottom: 1px solid #f1f5f9; color: #334155; vertical-align: top; }
        .badge { display: inline-block; padding: 4px 8px; border-radius: 4px; font-family: 'Fira Code', monospace; font-weight: 700; font-size: 0.85rem; }
        .badge-red { background: #fee2e2; color: #991b1b; }
        .badge-green { background: #dcfce7; color: #166534; }
        .badge-blue { background: #dbeafe; color: #1e40af; }
        .badge-yellow { background: #fef3c7; color: #92400e; }

    </style>
</head>
<body>

    <header>
        <div class="brand">
            <span class="emoji">üå≤</span>
            <div>
                <h1>Heap Sort</h1>
            </div>
        </div>
    </header>

    <div class="workbench">
        
        <main class="visual-area">
            <div class="stage-container">
                <div class="stage-header">
                    <div class="panel-title" style="margin:0; font-size: 1.1rem;">üëÄ Visual Example</div>
                    <div class="header-controls">
                        <div class="status-badge" id="statusText">Ready to Sort</div>
                    </div>
                </div>

                <div class="visual-body">
                    <div class="canvas-wrapper">
                        <canvas id="treeCanvas"></canvas>
                    </div>

                    <div class="trace-wrapper">
                        <div class="trace-header">
                            <span>Step Log</span>
                            <button onclick="clearLog()" style="border:none; background:none; cursor:pointer; color:#94a3b8;" title="Clear Log">üóëÔ∏è</button>
                        </div>
                        <div class="trace-log-container" id="traceLog">
                            <div style="color:#9ca3af; text-align:center; margin-top:50px; font-size:0.9rem;">
                                Press Play to see the sort trace...
                            </div>
                        </div>
                    </div>
                </div>

                <div class="controls-toolbar">
                    <div class="control-group">
                        <input type="text" id="customInput" placeholder="e.g. 50, 20, 10, 40">
                        <button class="btn" onclick="initCustom()">Load</button>
                        
                        <div class="dropdown">
                            <button class="btn">Generate ‚ñæ</button>
                            <div class="dropdown-content">
                                <div class="dropdown-item" onclick="initBest()">Best Case</div>
                                <div class="dropdown-item" onclick="initRandom()">Average (Random)</div>
                                <div class="dropdown-item" onclick="initWorst()">Worst Case</div>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <button class="btn btn-primary" id="btnPlay" onclick="startSort()">Play ‚ñ∂</button>
                        <button class="btn" id="btnPause" onclick="pauseSort()" disabled>Pause ‚è∏</button>
                        <button class="btn" id="btnStep" onclick="stepSort()">Step ‚è≠</button>
                        <button class="btn btn-danger" onclick="reset()">Reset ‚Ü∫</button>
                    </div>

                    <div class="control-group" style="border:none">
                        <label for="speedRange" style="font-size:0.85rem; font-weight:600; margin-right:8px;">Speed:</label>
                        <input type="range" id="speedRange" min="50" max="1000" value="500" style="width:100px;">
                    </div>
                </div>
            </div>
        </main>

        <section class="theory-area">
            <div class="details-panel">
                <div class="panel-title"><span>üéØ Real World Scenario</span></div>
                <div class="scenario-content">
                    Project Management: You have a "To-Do" pile. You always want to pick the most urgent task (Max Heap). Once you finish it, you pick the next most urgent. Heap Sort turns the array into this priority pile, repeatedly picking the largest item and moving it to the finished stack.
                </div>
                <div class="panel-title"><span>‚öôÔ∏è How It Works</span></div>
                <div class="logic-list">
                    <ol>
                        <li><strong>Build Max Heap:</strong> Organize array so every parent node is larger than its children. The largest item ends up at root (index 0).</li>
                        <li><strong>Swap:</strong> Move the root (largest) to the end of the array. It is now sorted.</li>
                        <li><strong>Heapify:</strong> Repair the heap property for the remaining unsorted section.</li>
                        <li>Repeat until the heap is empty.</li>
                    </ol>
                </div>
            </div>

            <div class="details-panel">
                <div class="panel-title"><span>üíª Code Implementation</span></div>
                <div class="code-container">
                    <div class="code-header-row">
                        <div class="code-tabs">
                            <button class="tab active" onclick="setLang('python')">Python</button>
                            <button class="tab" onclick="setLang('cpp')">C++</button>
                            <button class="tab" onclick="setLang('js')">JS</button>
                        </div>
                        <div class="view-mode-tabs">
                            <button class="view-btn active" id="btn-standard" onclick="setViewMode('standard')">Code</button>
                            <button class="view-btn" id="btn-time" onclick="setViewMode('time')">‚è± Time</button>
                            <button class="view-btn" id="btn-space" onclick="setViewMode('space')">üíæ Space</button>
                        </div>
                    </div>
                    <div class="code-editor" id="codeDisplay"></div>
                </div>
            </div>
        </section>

        <div class="complexity-section">
            <div class="panel-title">üìä Elaborated Complexity Analysis</div>
            <table class="complexity-table">
                <thead>
                    <tr>
                        <th width="15%">Metric</th>
                        <th width="15%">Complexity</th>
                        <th>Explanation</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Best Case</strong></td>
                        <td><span class="badge badge-green">O(n log n)</span></td>
                        <td>Heap Sort has no "early exit". It must build the heap and then remove elements one by one, each taking log n time.</td>
                    </tr>
                    <tr>
                        <td><strong>Average Case</strong></td>
                        <td><span class="badge badge-green">O(n log n)</span></td>
                        <td>Very consistent performance. Unlike Quick Sort, it has no worst-case quadratic scenario based on input order.</td>
                    </tr>
                    <tr>
                        <td><strong>Worst Case</strong></td>
                        <td><span class="badge badge-green">O(n log n)</span></td>
                        <td>Guaranteed log-linear time makes it reliable for real-time systems where consistency matters more than raw average speed.</td>
                    </tr>
                    <tr>
                        <td><strong>Space</strong></td>
                        <td><span class="badge badge-blue">O(1)</span></td>
                        <td><strong>In-Place Sort.</strong> The heap structure is implicit within the array indices (Left=2i+1, Right=2i+2). No extra memory needed.</td>
                    </tr>
                </tbody>
            </table>
        </div>

    </div>

    <script>
        // --- DATA & STATE ---
        const codeSnippets = {
            python: {
                standard: ["def heapify(arr, n, i):", "    largest = i", "    l = 2 * i + 1; r = 2 * i + 2", "    if l < n and arr[l] > arr[largest]: largest = l", "    if r < n and arr[r] > arr[largest]: largest = r", "    if largest != i:", "        arr[i], arr[largest] = arr[largest], arr[i]", "        heapify(arr, n, largest)", "def heap_sort(arr):", "    n = len(arr)", "    # Build Max Heap", "    for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i)", "    # Extract elements", "    for i in range(n - 1, 0, -1):", "        arr[i], arr[0] = arr[0], arr[i]", "        heapify(arr, i, 0)"],
                time: ["# TIME COMPLEXITY: O(n log n)", "def heap_sort(arr):", "    # Build Heap: O(n)", "    for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i)", "", "    # Extract Elements: n times", "    for i in range(n - 1, 0, -1):", "        # Swap: O(1)", "        # Heapify: O(log n) height of tree", "        heapify(arr, i, 0)", "# Total: O(n + n log n) = O(n log n)"],
                space: ["# SPACE COMPLEXITY: O(1)", "def heapify(arr, n, i):", "    # Recursive calls use stack space O(log n)", "    # Iterative implementation uses O(1)", "", "def heap_sort(arr):", "    # No auxiliary arrays created.", "    # Sorting happens in-place by swapping."]
            },
            cpp: {
                standard: ["void heapify(vector<int>& arr, int n, int i) {", "    int largest = i;", "    int l = 2 * i + 1; int r = 2 * i + 2;", "    if (l < n && arr[l] > arr[largest]) largest = l;", "    if (r < n && arr[r] > arr[largest]) largest = r;", "    if (largest != i) {", "        swap(arr[i], arr[largest]);", "        heapify(arr, n, largest);", "    }", "}", "void heapSort(vector<int>& arr) {", "    int n = arr.size();", "    for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);", "    for (int i = n - 1; i > 0; i--) {", "        swap(arr[0], arr[i]);", "        heapify(arr, i, 0);", "    }", "}"],
                time: ["// TIME COMPLEXITY: O(n log n)", "void heapSort(vector<int>& arr) {", "    // Build Heap: O(n)", "    for (int i = n / 2 - 1; i >= 0; i--) ...", "    // Extract Max: Loop n times", "    for (int i = n - 1; i > 0; i--) {", "        swap(arr[0], arr[i]);", "        heapify(arr, i, 0); // O(log n)", "    }", "}"],
                space: ["// SPACE COMPLEXITY: O(1)", "void heapify(...) {", "    // In-place swaps.", "    // No vectors allocated.", "    // Recursion stack is minimal.", "}"]
            },
            js: {
                standard: ["async function heapify(arr, n, i) {", "    let largest = i, l = 2*i+1, r = 2*i+2;", "    if (l < n && arr[l] > arr[largest]) largest = l;", "    if (r < n && arr[r] > arr[largest]) largest = r;", "    if (largest != i) {", "        [arr[i], arr[largest]] = [arr[largest], arr[i]];", "        await heapify(arr, n, largest);", "    }", "}", "async function heapSort(arr) {", "    let n = arr.length;", "    for (let i = Math.floor(n/2)-1; i >= 0; i--) await heapify(arr, n, i);", "    for (let i = n-1; i > 0; i--) {", "        [arr[0], arr[i]] = [arr[i], arr[0]];", "        await heapify(arr, i, 0);", "    }", "}"],
                time: ["// TIME COMPLEXITY", "async function heapSort(arr) {", "    // 1. Build Max Heap: O(n)", "    for (...) await heapify(...);", "    // 2. Extract Max: O(n log n)", "    for (let i = n-1; i > 0; i--) {", "        await heapify(arr, i, 0);", "    }", "}"],
                space: ["// SPACE COMPLEXITY: O(1)", "async function heapify(...) {", "    // Implicit tree structure in array.", "    // No extra memory allocation.", "}"]
            }
        };

        let currentData = [50, 20, 90, 10, 80, 30, 70, 40, 60, 100];
        let sorting = false;
        let paused = false;
        let abort = false;
        let resolveStep = null;
        let currentLang = 'python';
        let currentMode = 'standard';
        let stepCount = 0;
        
        window.onload = () => { renderCode(); initRandom(); };

        function setLang(lang) {
            currentLang = lang;
            document.querySelectorAll('.code-tabs .tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            renderCode();
        }

        function setViewMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.view-mode-tabs .view-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');
            renderCode();
        }

        function renderCode() {
            const container = document.getElementById('codeDisplay');
            container.innerHTML = '';
            codeSnippets[currentLang][currentMode].forEach((line, idx) => {
                const div = document.createElement('div');
                div.className = 'code-line'; div.id = `line-${idx}`; 
                if (currentMode !== 'standard' && (line.includes('//') || line.includes('#'))) {
                    const cls = currentMode === 'time' ? 'comment-time' : 'comment-space';
                    div.innerHTML = line.replace(/(\/\/|#)(.*)/, `<span class="${cls}">$1$2</span>`);
                } else if (currentMode === 'standard' && (line.includes('//') || line.includes('#'))) {
                     div.innerHTML = line.replace(/(\/\/|#)(.*)/, `<span class="comment-std">$1$2</span>`);
                } else div.innerText = line;
                container.appendChild(div);
            });
        }

        function highlightLine(lineIndex) {
            document.querySelectorAll('.code-line').forEach(l => l.classList.remove('active-line'));
            const el = document.getElementById(`line-${lineIndex}`);
            if (el) el.classList.add('active-line');
        }

        // --- TREE VISUALIZATION LOGIC ---

        function drawBars(highlights = {}) {
            const canvas = document.getElementById('treeCanvas');
            const ctx = canvas.getContext('2d');
            
            // Resize canvas to fit its container
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const n = currentData.length;
            if (n === 0) return;

            const nodeRadius = 20;
            const levelHeight = 60;
            
            // Calculate positions for all nodes
            const positions = [];
            const maxLevel = Math.floor(Math.log2(n));
            
            for (let i = 0; i < n; i++) {
                const level = Math.floor(Math.log2(i + 1));
                const nodesInLevel = Math.pow(2, level);
                const positionInLevel = i - nodesInLevel + 1;
                
                // Calculate horizontal position. We divide the canvas width
                // into 'nodesInLevel + 1' segments and place nodes at segment boundaries.
                const x = (canvas.width / (nodesInLevel + 1)) * (positionInLevel + 1);
                const y = (level + 1) * levelHeight;
                positions.push({x, y});
            }

            // Draw connecting lines first
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            for (let i = 0; i < n; i++) {
                const leftChildIdx = 2 * i + 1;
                const rightChildIdx = 2 * i + 2;
                
                if (leftChildIdx < n) {
                    ctx.beginPath();
                    ctx.moveTo(positions[i].x, positions[i].y);
                    ctx.lineTo(positions[leftChildIdx].x, positions[leftChildIdx].y);
                    ctx.stroke();
                }
                if (rightChildIdx < n) {
                    ctx.beginPath();
                    ctx.moveTo(positions[i].x, positions[i].y);
                    ctx.lineTo(positions[rightChildIdx].x, positions[rightChildIdx].y);
                    ctx.stroke();
                }
            }

            // Draw nodes
            for (let i = 0; i < n; i++) {
                const {x, y} = positions[i];
                const val = currentData[i];
                
                // Determine color based on highlights
                let bgColor = '#eee'; // default white/light grey
                let borderColor = '#333';

                if (highlights[i] === 'parent') {
                    bgColor = '#f97316'; // orange
                    borderColor = '#c2410c';
                } else if (highlights[i] === 'child') {
                    bgColor = '#fef08a'; // yellow
                }

                ctx.beginPath();
                ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);
                ctx.fillStyle = bgColor;
                ctx.fill();
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw Value
                ctx.fillStyle = '#000';
                ctx.font = 'bold 14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(val, x, y);

                // Draw Index (red, below node)
                ctx.fillStyle = 'red';
                ctx.font = 'bold 12px Fira Code, monospace';
                ctx.fillText(i, x, y + nodeRadius + 12);
            }
        }

        // --- LOGS ---
        function addLog(title, msg, arrState) {
            stepCount++;
            const container = document.getElementById('traceLog');
            if (container.children.length > 0 && container.children[0].innerText.includes('Press Play')) {
                container.innerHTML = '';
            }

            const stepDiv = document.createElement('div');
            stepDiv.className = `trace-step`;
            
            // Array snapshot logic
            let arrayHtml = '';
            if (arrState) {
                arrayHtml = `<div class="array-state">[ ${arrState.join(', ')} ]</div>`;
            }

            stepDiv.innerHTML = `
                <div style="display:flex; justify-content:space-between;">
                    <span class="step-info">STEP ${stepCount}: ${title}</span>
                </div>
                <div class="step-msg">${msg}</div>
                ${arrayHtml}
            `;
            container.appendChild(stepDiv);
            container.scrollTop = container.scrollHeight;
        }

        function clearLog() {
            document.getElementById('traceLog').innerHTML = '<div style="color:#9ca3af; text-align:center; margin-top:50px; font-size:0.9rem;">Log Cleared</div>';
            stepCount = 0;
        }

        function initRandom() { reset(); currentData = Array.from({length: 12}, () => Math.floor(Math.random() * 90) + 10); drawBars(); updateStatus("Ready (Random)"); }
        function initBest() { reset(); currentData = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]; drawBars(); updateStatus("Ready (Sorted)"); }
        function initWorst() { reset(); currentData = [100, 90, 80, 70, 60, 50, 40, 30, 20, 10]; drawBars(); updateStatus("Ready (Reverse)"); }
        function initCustom() {
            const input = document.getElementById('customInput').value;
            if(!input) return;
            const arr = input.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
            if(arr.length > 0) { reset(); currentData = arr; drawBars(); }
        }

        function reset() {
            abort = true; sorting = false; paused = false;
            stepCount = 0;
            if (resolveStep) resolveStep(); 
            updateStatus("Ready"); enableControls(true); highlightLine(-1);
            drawBars(); 
            document.getElementById('traceLog').innerHTML = '<div style="color:#9ca3af; text-align:center; margin-top:50px; font-size:0.9rem;">Press Play...</div>';
            document.getElementById('btnPause').classList.remove('active');
        }

        // --- CONTROLS ---
        async function startSort() {
            if (paused) {
                paused = false; document.getElementById('btnPause').classList.remove('active');
                if (resolveStep) resolveStep(); updateStatus("Resuming..."); return;
            }
            if (sorting) return;

            sorting = true; abort = false; enableControls(false);
            stepCount = 0;
            document.getElementById('traceLog').innerHTML = ''; 
            
            await heapSortAlgo();
            
            if (!abort) {
                drawBars(); // Final redraw
                document.getElementById('statusText').innerText = "Sorted!";
                addLog("COMPLETE", "Array is fully sorted.", currentData);
                updateStatus("Sorting Complete! üéâ");
            }
            sorting = false; enableControls(true); highlightLine(-1);
            document.getElementById('btnPause').classList.remove('active');
        }

        function pauseSort() {
            if (!sorting || paused) return;
            paused = true; updateStatus("Paused");
            document.getElementById('btnPause').classList.add('active'); 
        }

        function stepSort() {
            if (!sorting) { startSort(); paused = true; document.getElementById('btnPause').classList.add('active'); return; }
            paused = false; if(resolveStep) resolveStep(); paused = true; document.getElementById('btnPause').classList.add('active');
        }

        function enableControls(enabled) {
            document.getElementById('btnPlay').disabled = !enabled;
            document.getElementById('btnPause').disabled = enabled;
            document.getElementById('customInput').disabled = !enabled;
        }

        function updateStatus(msg) { document.getElementById('statusText').innerText = msg; }

        async function wait() {
            if (abort) return Promise.reject("Aborted");
            const rawSpeed = document.getElementById('speedRange').value; 
            const delay = 1050 - rawSpeed; 
            if (paused) await new Promise(resolve => { resolveStep = resolve; });
            else await new Promise(resolve => setTimeout(resolve, delay));
        }

        // --- HEAP SORT ---
        
        async function heapSortAlgo() {
            let n = currentData.length;

            // 1. Build Heap
            addLog("PHASE 1", "Building Max Heap from array.", currentData);
            updateStatus("Building Max Heap");
            highlightLine(11);
            
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                await heapify(n, i);
            }

            // 2. Extract
            addLog("PHASE 2", "Heap built. Extracting elements one by one.", currentData);
            updateStatus("Extracting Max Elements");
            highlightLine(13);

            for (let i = n - 1; i > 0; i--) {
                if(abort) return;
                
                // Swap Root with End
                updateStatus(`Moving Max ${currentData[0]} to end (index ${i})`);
                addLog("SWAP", `Swapping Root <span class='hl-parent'>${currentData[0]}</span> with End <span class='hl-child'>${currentData[i]}</span>`, currentData);
                highlightLine(14);
                
                // Visual Swap
                drawBars({0: 'parent', [i]: 'child'});
                await wait();
                
                [currentData[0], currentData[i]] = [currentData[i], currentData[0]];
                
                drawBars(); // Redraw after swap
                await wait();

                // Repair Heap
                highlightLine(15);
                await heapify(i, 0); // reduced heap size 'i'
            }
        }

        async function heapify(n, i) {
            if(abort) return;
            highlightLine(0);

            let largest = i;
            let l = 2 * i + 1;
            let r = 2 * i + 2;

            // Visual: Highlight Parent being checked
            let h = {};
            h[i] = 'parent';
            // Mark children if exist and are within current heap size
            if(l < n) h[l] = 'child';
            if(r < n) h[r] = 'child';
            
            drawBars(h);
            updateStatus(`Heapify: Checking Parent ${currentData[i]}`);
            await wait();

            highlightLine(3);
            if (l < n && currentData[l] > currentData[largest]) {
                largest = l;
            }

            highlightLine(4);
            if (r < n && currentData[r] > currentData[largest]) {
                largest = r;
            }

            if (largest != i) {
                addLog("FIX HEAP", `Parent <span class='hl-parent'>${currentData[i]}</span> smaller than Child <span class='hl-child'>${currentData[largest]}</span>. Swapping.`, currentData);
                
                highlightLine(6);
                // Visual Swap
                [currentData[i], currentData[largest]] = [currentData[largest], currentData[i]];
                
                // Update Visuals
                drawBars({[i]: 'child', [largest]: 'parent'});
                await wait();

                highlightLine(7);
                await heapify(n, largest);
            }
        }
    </script>
</body>
</html>